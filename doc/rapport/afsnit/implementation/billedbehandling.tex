{
{\sffamily I det følgende, kaster vi et blik på detjlerne i programmets
billedbehandlingsmetoder. Efter en teknisk introduktion til digitale
billeder vises det, hvilke datastrukturer og metoder \emph{OpenCV}
stiller til rådighed, samt hvordan disse bruges, til at udtrække
regioner i digitale billeder. Endeligt vil vi undersøge, hvilke
svagheder vores implementation, til udtrækning af regioner, har.
}

\subsection{Digitale billeder}
I afsnit \ref{section_kort_intro} blev der givet en kort introduktion
til den digitale repræsentation af billeder. Det blev antaget, at en
pixel kunne antage værdier i mængden $\{0, 1\}$, men i praksis, kan
pixels godt antage andre værdier. Vi arbejder med billeder, hvor værdien
for hver pixel er repræsenteret ved tre 8 bit størrelser, hver med
værdier i mængden $\{0, 1, 2, \cdots, 254, 255\}$. Sammensætningen af de
tre værdier, som beskrives som kanaler eller farvebånd, kaldes for en
RGB-farve, hvor tallene repræsenteret ved $(R,G,B)$ angiver mængden af
hhv. rød, grøn og blå farve i en pixel. Et sådant billede, kaldes for et
RGB-billede. Vores korpus består af sådanne RGB-billeder med 8 bits, og
vi benytter derfor også denne repræsentation internt. Der er enkelte
undtagelser, hvor der kun bruges én kanal, således at vi arbejder med
gråtonebilleder. For en uddybning af billeders repræsentation henvises
til \cite{SIOlsen}.

Vi har også tidligere, i ligning \ref{billede_matrix},  vist, at et
digitalt billede kan skrives som en matrix. Ved denne matrix, kan man få
værdien for en pixel med koordinater $(x,y)$ ved elementet
$\mathbf{I}_{xy}$. Vi har altså, at x-aksen går fra øverste venstre
hjørne i nedadgående retning og y-aksen fra øverste venstre hjørne mod
højre. \emph{OpenCV} bruger dog et andet koordinatsystem, hvor akserne
er vendt om, som vist i figur \ref{opencv_koordinatsystem}. Man skal
derfor huske på at matricen, som\emph{OpenCV} bruger, er transponeret,
og vi skal derfor bytte om på koordinaterne. For at få værdien på den
pixel med koordinaterne $(x,y)$, skal vi altså bruge værdien
$\mathbf{I}_{yx}$, hvor de omvendte koordinater bør bemærkes.

\begin{figure}[!b]
    \centering
    \begin{picture}(122,55)
        \put(61, 50){$x$}
        \put(-10, 22){$y$}
        \put(0, 45){\circle*{3}}
        \put(-1, 45){\vector(1, 0){120}}
        \put(0, 45){\vector(0, -1){48}}

    \end{picture}
    \caption[]{Koordinatsystemet, som bliver brugt i \emph{OpenCV}.}
    \label{opencv_koordinatsystem}
\end{figure}

Billedematricen $\mathbf{I}$, repræsenteres i \emph{OpenCV} som et
dobbelt-array. I figur \ref{opencv_billedematrix} er vist hvordan
denne struktur ser ud, når vi har indlæst billedet givet i figur
\ref{billede_pixels}. Hvis billedet er indlæst i variablen \texttt{I},
kan vi i Python, tilgå pixelen med koordinater $(x,y) = (0,2)$ ved
$\textbf{I}_{2,0} =~$\texttt{I[2][0]}.

\begin{figure}[t]
    \begin{verbatim}
                        I = [ [0, 1, 0],
                              [1, 1, 1],
                              [0, 1, 0] ]
    \end{verbatim}
\vspace{-2em}
\caption{Repræsentation af billedematricen fra ligning
\ref{billede_pixels} i \emph{OpenCV}.}
\label{opencv_billedematrix}
\end{figure}

\subsection{Resultaters struktur\label{resultat_struktur}}
Indledningsvist vil vi introducere nogle vigtige datastrukturer, som vi
bruger fra \emph{OpenCV}. Alle datastrukturer og metoder fra
\emph{OpenCV}, har præfikset ``cv'', hvilket gør det let, at skelne
vores egne metoder fra dem der er givet i \emph{OpenCV}. Vi præsenterer
desuden en notation for datastrukturer, der er underlagt strukturen vist
i \eqref{types_class}.
\begin{multline}
    \textbf{class~} [\textit{name}] = \{ \\
    \shoveleft{\qquad[\textit{type}] : [\textit{varName}]} \\
    \shoveleft{\}}\shoveright{}
    \label{types_class}
\end{multline}
I \eqref{example_class} ses et eksempel på en struktur kaldet
\textbf{ExampleClass}.
\begin{multline}
    \textbf{class~} \textrm{ExampleClass} = \{ \\
    \shoveleft{\qquad\textbf{int} : \textit{intValue}} \\
    \shoveleft{\qquad\textbf{string} : \textit{stringValue}} \\
    \shoveleft{\qquad\textbf{int[2]} : \textit{arrayValues}} \\
    \shoveleft{\}}\shoveright{}
    \label{example_class}
\end{multline}
Når en type har et suffiks af formen $\textit{type}[i]$, hvor $i$ er et
heltal, betyder det, at dette er en liste af længde $i$ af typen
\textit{type}.  Bemærk, at en strukturs navn bliver skrevet med fed
skrift i brødteksten, når der refereres til en sådan. Ligeledes vil en
strukturs navn blive skrevet med fed i pseudokoden, hvis der refereres
til den. Vi kan definere en ny struktur, \textbf{NewClass}, som
illustrerer dette, i \eqref{new_class} herunder.
\begin{multline}
    \textbf{class~} \textrm{NewClass} = \{ \\
    \shoveleft{\qquad\textbf{ExampleClass} : \textit{exampleInstance}} \\
    \shoveleft{\qquad\textbf{string} : \textit{stringValue}} \\
    \shoveleft{\}}\shoveright{}
    \label{new_class}
\end{multline}
Vi vil nu beskrive de vigtigste datastrukturer, som vi bruger, med
ovenstående notation.

\subsubsection{cvScalar}
Strukturen \textbf{cvScalar} fungerer egentlig som en almindelig liste
med værdier, blot kan en instans af \textbf{cvScalar} kun indeholde 1,
2, 3 eller 4 værdier. Strukturen vist i \eqref{cvScalar_class} har fire
værdier.
\begin{multline}
    \textbf{class~} \textrm{cvScalar} = \{ \\
    \shoveleft{\qquad\textbf{double[4]} : \textit{value}} \\
    \shoveleft{\}}\shoveright{}
    \label{cvScalar_class}
\end{multline}
I \emph{OpenCV}, og i vores implementation i øvrigt, bruges strukturen
blandt andet til RGB-farver og tærskelværdier. Til RGB-værdier bruger
\emph{OpenCV} også strukturen \textbf{CV\_RGB}, men dette er reelt blot
en instans af \textbf{cvScalar}.

\subsubsection{cvPoint}
Strukturen \textbf{cvPoint} har til formål at beskrive punkter i det
to-dimensionelle plan. Den er givet i \eqref{cvPoint_class}.
\begin{multline}
    \textbf{class~} \textrm{cvPoint} = \{ \\
    \shoveleft{\qquad\textbf{int} : \textit{x}} \\
    \shoveleft{\qquad\textbf{int} : \textit{y}} \\
    \shoveleft{\}}\shoveright{}
    \label{cvPoint_class}
\end{multline}
Det er en simpel struktur, men den er en meget central del af
implementationen.  Den bruges blandt andet til at angive snit i billedet
samt til at fortælle floodfill, hvor vi skal male og skifte farve.

\subsubsection{cvRect}
Denne struktur beskriver et rektangel, ved at angive dets øverste venstre
hjørne og dets dimensioner. Strukturen vises i \eqref{cvRect_class}.
\begin{multline}
    \textbf{class~} \textrm{cvRect} = \{ \\
    \shoveleft{\qquad\textbf{int} : \textit{x}} \\
    \shoveleft{\qquad\textbf{int} : \textit{y}} \\
    \shoveleft{\qquad\textbf{int} : \textit{height}} \\
    \shoveleft{\qquad\textbf{int} : \textit{width}} \\
    \shoveleft{\}}\shoveright{}
    \label{cvRect_class}
\end{multline}
I vores implementation af den naive fremgangsmåde, som nævnt i afsnit
\ref{section_naiv}, er det denne struktur, som angiver en regions
begrænsende rektangel. Vi vil i afsnit \ref{section_vurdering_regioner},
se, hvordan strukturen \textbf{cvRect} bruges til at vurdere, om regioner
ligger i det gyldne snit.

\subsubsection{cvConnectedComp}
\emph{OpenCV} har en implementation af den floodfill-metode beskrevet i
afsnit \ref{subsec_floodfill}. Vi vil komme nærmere ind på denne senere,
men den nævnes nu, da den gør brug af en datastruktur kaldet
\textbf{cvConnectedComp}. Denne struktur bruges, til at beskrive den
region i billedet, som floodfill fylder ud.  Strukturen er vist i
\eqref{cvConnectedComp_class}.
\begin{multline}
    \textbf{class~} \textrm{cvConnectedComp} = \{ \\
    \shoveleft{\qquad\textbf{double} : \textit{area}} \\
    \shoveleft{\qquad\textbf{float} : \textit{value}} \\
    \shoveleft{\qquad\textbf{cvRect} : \textit{rect}} \\
    \shoveleft{\}}\shoveright{}
    \label{cvConnectedComp_class}
\end{multline}
Strukturen indeholder en regions begrænsende rektangel og regionens
areal.

\subsubsection{Resultater}
Vi vil nu introducere en ny struktur, som repræsenterer Pythons
\emph{dictionary}, forkortet \emph{dict}.  En \emph{dict} viser vi som i
\ref{def_dict}.
\begin{eqnarray}
    \langle[\textit{dictName}]\rangle = \{ [\textit{key}] : [\textit{data}] \}
    \label{def_dict}
\end{eqnarray}
Som et simpelt eksempel, kan vi konstruere en \emph{dict}
$\angles{LuckyNumbers}$, som indeholder personers lykketal:
% TeX-Gods, please forgive me :(
\begin{multline}
    \angles{LuckyNumbers} = \{ \qquad \textrm{Tom Cruise} : 4 , \\
    \textrm{Arthur Dent} : 42 \qquad\qquad\\
    \shoveleft{\}}\shoveright{}
    \label{lucky_dict}
\end{multline}
% In honor of the danish Tom Cruise
Data i en \emph{dict}, kan godt være af mere komplicerede typer, f.eks.
kan man have en anden \emph{dict}. Man kan således lave en hierakisk
struktur, som egner sig opbevaring af fundne regioner i et billede. Vi
ønsker at have hierakiet vist i figur \ref{resultat_hieraki}.

\begin{figure}[!h]
    \dirtree{%
    .1 $\textrm{ImageRegions}$ .
    .2 $\textrm{RatioRegions}$ .
    .3 $\textrm{CutRegions}$ .
    .4 $region0$ .
    .4 $region1$ .
    .4 $region2$ .
    .2 $\textrm{RatioRegions}$ .
    .3 $\textrm{CutRegions}$ .
    .2 $\textrm{RatioRegions}$ .
    .2 \dots .
    }
    \caption[]{Hierakisk struktur til resultater}
    \label{resultat_hieraki}
\end{figure}

Vi har, at et billede kan have et endeligt antal snitratioer, som man
ønsker at undersøge. Disse snitratioer, har enten to eller fire snit,
som nævnt i afsnit \ref{section_opdeling}. I disse snit er der et
endeligt antal fundne regioner. Vi repræsenterer hver node i figur
\ref{resultat_hieraki} med en \emph{dict}. På nederste niveau har vi
selve regionen, som floodfill-metoden har lagt i strukturen
\textbf{cvConnectedComp}. Vi ønsker dog også, at gemme hvilken farve,
regionen er blevet tildelt i det segmenterede billede. Vi gemmer derfor
parret $(color, region)$, som er instanser af henholdsvis
\textbf{CV\_RGB} og \textbf{cvConnectedComp}. Hver region bliver tildelt
et \emph{id}, som er en strengrepræsentation af regionens farve.  Hvis
det antages, at regionens farve er hvid, vil den have RGB-værdien $(255,
255, 255)$ og den får derfor tildelt $id = \textrm{'255255255'}$.
Regioners id er kun unikt for et givet snit. Vi konstruerer nu
$\angles{CutRegions}$, som indeholder de fundne regioner for et snit.
$\angles{CutRegions}$ er vist herunder i \eqref{CutRegions_dict}.
\begin{multline}
    \angles{CutRegions} = \{ \textit{~RegionId} : \\
    (\textbf{CV\_RGB~}\textit{color}, \textbf{cvConnectedComp~}\textit{region}) \}\quad
    \label{CutRegions_dict}
\end{multline}

\noindent I $\angles{CutRegions}$ bruges regionens id som nøgle. Vi kan nu
konstruere den \emph{dict} i niveauet over som vi betegner
$\angles{RatioRegions}$. Den ses i \eqref{RatioRegions_dict}.
\begin{eqnarray}
    \angles{RatioRegions} = \{ \textit{~CutNo} : \angles{CutRegions} \}
    \label{RatioRegions_dict}
\end{eqnarray}

\noindent $\angles{RatioRegions}$ holder alle regioner for en givet
snitratio.  Hvert snit, tilknyttet en snitratio, blev i afsnit
\ref{section_opdeling}, tildelt et id i mængden $\{0,1,2,3\}$. Vi bruger
snittets id som nøgle.  Data i $\angles{RatioRegions}$ er den instans af
$\angles{CutRegions}$ som tilhører snittet.

Det sidste niveau i hierakiet fra figur \ref{resultat_hieraki}, er endnu
en \emph{dict} givet ved $\angles{ImageRegions}$ vist i
\eqref{ImageRegions_dict}.
\begin{eqnarray}
    \angles{ImageRegions} = \{ \textit{~CutRatio} : \angles{RatioRegions} \}
    \label{ImageRegions_dict}
\end{eqnarray}

\noindent $\angles{ImageRegions}$ har nøglen $CutRatio$, som angiver en
snitratio til et billede. Hver snitratio har et antal snit, som endeligt
har et antal fundne regioner. Vi har således fået beskrevet den
struktur, som resultater bliver repræsenteret ved.

Resultatet fra en analyse på et billede, med snitratioerne $0.5$ og
$0.618$, ligner da det nedenstående:
%% !!! Bwadr-tex !!!
\begin{multline}
    \angles{ImageRegions} = \{ 0.5 : \{ 0 : \{ \textrm{'012345678'} : (color, region) \},\\
                                            \{ \textrm{'123456789'} : (color, region) \}
                                            \},\\
                                            \{ 1 : \{ \textrm{'012345678'} : ( \cdots ) \}, 
                                            \{ \cdots \} \}, \\
                              0.618 : \{ 0 : \{ \cdots \} \}, \{ 1 :
                              \cdots \}, \{ 2 : \cdots \}, \{ 3 : \cdots
                              \} \\
    \shoveleft{\}}\shoveright{}
    \label{CutRegions_dict}
\end{multline}

\subsection{Udtrækning af regioner}
I afsnit \ref{sammensaetning_af_metoder} er der givet en overordnet
fremgangsmåde, for at trække regioner ud af billedet, i forhold til et
givet snit. Resten af dette afsnit, vil omhandle den egentlige
implementation af denne fremgangmåde og problemerne tilknyttet.
Indledningsvist vises, hvordan snit i billedet repræsenteres.

\subsubsection{Repræsentation af snit i billedet}
Vi tidligere, i afsnit \ref{section_opdeling}, argumenteret for, hvordan
vi finder det gyldne snit i et billede. Det er nævnt, at man ikke
nødvendigvis behøver at betragte det gyldne snit, men vi kan arbejde med
helt arbitrære snit. Vi vil derfor blot referere til \emph{snit i
billedet}, da den enkelte snitratio er underordnet. Metoderne i dette
afsnit er ikke specifikke for snitratioen $\varPhi$, men kan overføres
til ethvert andet snit i billedet, med en arbitrær snitratio.

Snit i et billede bliver imidlertid --- meget intuitivt --- blot
repræsenteret ved et linjestykke. Vi præsenterer nu datastrukturen
\textbf{Line}, som består af et linjestykkes to endepunkter.
\begin{multline}
    \textbf{class~} \textrm{Line} = \{ \\
    \shoveleft{\qquad\textbf{cvPoint} : \textit{p1}} \\
    \shoveleft{\qquad\textbf{cvPoint} : \textit{p2}} \\
    \shoveleft{\}}\shoveright{}
    \label{Line_class}
\end{multline}
Strukturen er simpel, men fleksibel, og lader mulighederne stå åbne,
for, i en anden implementation, at betragte andet end blot vand- og
lodrette snit i billedet.

\subsubsection{Præparation af billedet}
Det første skridt i præparation af billedet, inden udtrækningen af
regioner, er at detektere kanterne på objekter i billedet.  Som nævnt i
afsnit \ref{udtraek_kanter}, bruger vi kantdetektionsmetoden Canny.
\emph{OpenCV} har implementeret denne metode som \texttt{cvCanny}.
Metoden skal køres på et sort/hvid-billede, så vi starter med at lave en
sort/hvid kopi af det originale billede. Vi skal også bruge et tomt
output-billede, hvori kanterne kan indtegnes. Dette skal ligeledes være
et sort/hvid-billede. Resultatet fra \texttt{cvCanny} er tidligere vist
i figurene \ref{canny_kanter} og \ref{sammen_kanter}.

I andet skridt af fremgangsmåden sløres billedet, så vi tillader
floodfill-metoden at dække et større areal. \emph{OpenCV} stiller
metoden \texttt{cvSmooth} til rådighed, for sløring af billeder.
\texttt{cvSmooth} tager følgende argumenter: det oprindelige billede, et
billede hvori resultatet vises, dimensionerne på foldningsmatricen der
skal bruges samt hvilken sløringsmetode der ønskes brugt. Metoderne vist
i afsnit \ref{udtraek_sloering} er til rådighed ved at bruge
konstanterne \texttt{CV\_BLUR}, \texttt{CV\_GAUSSIAN} og
\texttt{CV\_MEDIAN}. Inden vi detekterer kanter i et billede, bruger vi
simpel sløring, da vi på denne måde kun betragter kanter, som fremstår
tydeligt i billedet.  Simpel sløring er hurtigt og effektiv, og bliver
derfor også brugt på billedet inden vi bruger floodfill-metoden.

Sidste skridt, inden den egentlige segmentering og udtrækning af
regioner, er fremhævelse af de detekterede kanter. Kanterne skal
fremhæves, da den simple sløringsmetode kan have visket nogle de
originale kanter ud.  Vi ønsker stadig, at kunne begrænse
floodfill-metoden, så vi kan holde regioner i billedet adskilt. Kanterne
fremhæves ved at oprette et nyt billede, med samme størrelse som
originalbilledet. Alle pixels, i det nye billede, farves sort. Alle
pixels, fra det originale billede, kopieres over i det nye billede, med
undtagelse af pixels, hvorpå der er detekteret en kant. Derved bliver
pixels med en kant, ikke farvet, dvs.  de forbliver sorte. At lade
kanterne være sorte kan have nogle utilsigtede konsekvenser. Vi henviser
til afsnit \ref{subsec_svagheder} for en gennemgang af disse.

\subsubsection{Segmentering med floodfill-metoden}
Vi beskriver nu metoden, til at trække regioner ud af et billede, der er
blevet præpareret som beskrevet ovenfor. Metoden bygger videre på
beskrivelsen givet i \ref{sammensaetning_af_metoder}, hvor
floodfill-metoden bruges på hver pixel langs et snit. I praksis er denne
fremgangsmåde meget langsom, især på store billeder. Vi vil derfor komme
frem til en metode, som kun bruger floodfill-metoden på de nødvendige
pixels.  Vi starter med, at forklare en meget naiv algoritme, som vi
løbende videreudvikler, for at komme frem til den endelige fremgangsmåde
for at trække regioner ud, af et præpareret billede. \emph{OpenCV} har
implementeret floodfill-metoden som \texttt{cvFloodFill} og det er denne
vi bruger, til at markere regioner i billedet.

Informationerne fra et kantdetekteret billede, kan hjælpe
\texttt{cvFloodFill} til at segmentere et billede, for endeligt at
trække regioner ud af dette. Hvis vi har et snit, repræsenteret ved en
instans af strukturen \textbf{Line}, kan vi gemme punkterne, hvor en
kant krydser snittet. Et eksempel, ses i figur
\ref{impUdtraek_kantpunkter}, hvor vi har et horisontalt snit,
repræsenteret ved linjestykket $AB$, og punkterne $e_1, \cdots, e_6$ er
der hvor en kant krydser. Vi antager i det følgende, at pixels, i
billedet vi undersøger, har RGB-værdier i mængden
$\{(0,0,0),(255,255,255)\}$, hvilket vil sige, at billedets pixels enten
er helt sorte eller helt hvide --- billedet vi undersøger er binært.

\begin{figure}[p]
    \centering
    \begin{picture}(240,30)
        \put(0, 10){$A$}
        \put(3, -5){\line(0, 1){10}}

        \put(82, 10){$e_1$}
        \put(85, 0){\circle*{3}}

        \put(102, 10){$e_2$}
        \put(105, 0){\circle*{3}}

        \put(134, 10){$e_3$}
        \put(137, 0){\circle*{3}}

        \put(158, 10){$e_4$}
        \put(161, 0){\circle*{3}}

        \put(200, 10){$e_5$}
        \put(203, 0){\circle*{3}}

        \put(221, 10){$e_6$}
        \put(224, 0){\circle*{3}}

        \put(233, 10){$B$}
        \put(236, -5){\line(0, 1){10}}

        \put(3, 0){\line(1, 0){233}}
    \end{picture}
    \caption[]{Punkter, hvor der er en kant der krydser snittet.}
    \label{impUdtraek_kantpunkter}
\end{figure}

\begin{figure}[p]
    \centering
    \begin{picture}(240,30)
        \color{red}
        \put(3, 0){\line(1, 0){81}}

        \color{green}
        \put(85, 0){\line(1, 0){20}}

        \color{blue}
        \put(105, 0){\line(1, 0){32}}

        \color{cyan}
        \put(137, 0){\line(1, 0){24}}

        \color{purple}
        \put(161, 0){\line(1, 0){42}}

        \color{orange}
        \put(203, 0){\line(1, 0){21}}

        \color{violet}
        \put(224, 0){\line(1, 0){12}}

        \color{black}

        \put(0, 10){$A$}
        \put(3, -5){\line(0, 1){10}}

        \put(82, 10){$e_1$}
        \put(85, 0){\circle*{3}}

        \put(102, 10){$e_2$}
        \put(105, 0){\circle*{3}}

        \put(134, 10){$e_3$}
        \put(137, 0){\circle*{3}}

        \put(158, 10){$e_4$}
        \put(161, 0){\circle*{3}}

        \put(200, 10){$e_5$}
        \put(203, 0){\circle*{3}}

        \put(221, 10){$e_6$}
        \put(224, 0){\circle*{3}}

        \put(233, 10){$B$}
        \put(236, -5){\line(0, 1){10}}

    \end{picture}
    \caption[]{Farvede linjestykker. \colbox{red}{$Ae_1$},
    \colbox{green}{$e_1e_2$}, \colbox{blue}{$e_2e_3$},
    \colbox{cyan}{$e_3e_4$}, \colbox{purple}{$e_4e_5$},
    \colbox{orange}{$e_5e_6$}, \colbox{violet}{$e_6B$}.
    }
    \label{impUdtraek_naiv_res}
\end{figure}

\begin{lstlisting}[caption={Naiv pseudokode til segmentering af binære
    billeder.},captionpos=b,label={naiv_segmentering},numbers=left,
    frame=tb, breaklines=false, float=p]
for lineSegment in Cut:
    # Get a new color that is not in the component dictionary
    color = getRandomColor()
    region = cvConnectedComp()

    center = getCenter(lineSegment)

    cv.cvFloodFill(img, center, color, lowerThres, upperThres, region)

\end{lstlisting}

\begin{lstlisting}[caption={Original pseudokode til udtrækning af
    regioner. Denne kan returnere den samme region flere
    gange.},captionpos=b,label={pseudo_udtraek_org},numbers=left,
    frame=tb, breaklines=false, float=h]
for lineSegment in Cut:
    # Get a new color that is not in the component dictionary
    color = getRandomColor()
    region = cvConnectedComp()

    for pixel in lineSegment:

        # Check if the color of the pixel equals current color
        if not (color(pixel) ==  color):

            # Check if the color of the pixel are in the saved regions
            if not (color(pixel) in CutRegions):
                cv.cvFloodFill(img, pixel, color, lowerThres, upperThres, region)

    # Color the last pixel again to make sure that
    # the returned component is the entire region
    cv.cvFloodFill(img, pixel, color, lowerThres, upperThres, region)

    # Put the results in the CutRegions-dictionary
    CutRegions[color.toString()] = (color, region)
\end{lstlisting}

Som vist i figur \ref{impUdtraek_kantpunkter}, kan snittet opdeles i
mindre linjestykker. Nu antager vi meget naivt, at punkterne på
linjestykket $Ae_1$ tilhører én region, mens punkterne på $e_1e_2$
tilhører en anden region, og så fremdeles. Med denne antagelse, samt
antagelsen om at billedet er binært, kan vi, for hvert linjestykke
mellem kanter, bruge \texttt{cvFloodFill} en enkelt gang. Hver gang vi
passerer en kant, maler \texttt{cvFloodFill} med en ny tilfældig farve.
Således skelnes regioner fra hinanden. \texttt{cvFloodFill} kaldes,
bland andet, med en en instans af \textbf{cvConnectedComp}, hvori den
netop farvede region lægges. Vi bruger \texttt{cvFloodFill} på midten af
hvert linjestykke og tildeler linjestykkerne tilfældige farver, som vist
i figur \ref{impUdtraek_naiv_res}. Pseudokode for fremgangsmåden vises i
kodeboks \ref{naiv_segmentering}.

Denne fremgangsmåde virker fint i det et-dimensionelle plan på binære
billeder, som i figur \ref{impUdtraek_naiv_res}, men i to dimensioner,
opstår der problemer med antagelsen om, at hvert linjestykke tilhører
sin egen region. Vi betragter nu figur \ref{region_extract}, hvor
\ref{region_init} er det oprindelige billede.  Snittet i figur
\ref{impUdtraek_kantpunkter} rammer altså de tre sorte kasser i figur
\ref{region_init}. Vi gennemgår nu iterationerne i fremgangsmåden fra
kodeboks \ref{naiv_segmentering}, på billedet i \ref{region_init}.
Disse er vist i figurene \ref{region1} til \ref{region7}.
\clearpage

\begin{enumerate}
    \item Linjestykket $Ae_1$ bliver malet rødt. Hele den hvide baggrund
        males rød og denne region returneres.
    \item Linjestykket $e_1e_2$ males. Den første kasse fra venstre
        bliver malet grøn. Denne region returneres.
    \item Linjestykket $e_2e_3$ males blåt, men dette er den samme region som
        fundet i første iteration. Der returneres alligevel en ny
        region.
    \item Linjestykket $e_3e_4$ males lyseblåt og udgøres af den
        midterste kasse, der returneres som en ny region.
    \item Linjestykket $e_4e_5$ bliver malet og endnu engang findes en
        region som vi allerede har fundet.
    \item Linjestykket $e_5e_6$ males orange og vi finder den sidste
        kasse.
    \item Linjestykket $e_6B$ males lilla og vi returnerer igen en
        allerede fundet region.
\end{enumerate}
Vi ender altså med at have returneret syv regioner, ligesom antallet af
linjestykker, men når vi kigger på resultatet, i figur \ref{region7}, er
der kun fire forskellige farver. Vi returnerer den samme region, den som
i originalen var hvid, i alt fire gange. Vi vil gerne undgå denne
opførsel, og gemmer derfor de fundne regioner, sammen med den farve
regionen er blevet tildelt. Således kan vi kontrollere farven på den
pixel vi står til at male, inden vi bruger \texttt{cvFloodFill}. Hvis
denne pixel har en farve lig en allerede returneret region, undlader vi
at male denne, da vi antager, at denne pixel er del af en allerede
returneret region.

\begin{figure}[!p]
    \setlength\fboxsep{0pt}
    \setlength\fboxrule{0.5pt}
    \centering
    \subfloat[Original]{
        \label{region_init}
        \fbox{\includegraphics[width=0.4\textwidth]{afsnit/implementation/billeder/billedbehandling/binary_init}}}\hspace{1em}
    \subfloat[1. iteration]{
        \label{region1}
        \fbox{\includegraphics[width=0.4\textwidth]{afsnit/implementation/billeder/billedbehandling/binary_s1}}}\\
    \subfloat[2. iteration]{
        \label{region2}
        \fbox{\includegraphics[width=0.4\textwidth]{afsnit/implementation/billeder/billedbehandling/binary_s2}}}\hspace{1em}
    \subfloat[3. iteration]{
        \label{region3}
        \fbox{\includegraphics[width=0.4\textwidth]{afsnit/implementation/billeder/billedbehandling/binary_s3}}}\\
    \subfloat[4. iteration]{
        \label{region4}
        \fbox{\includegraphics[width=0.4\textwidth]{afsnit/implementation/billeder/billedbehandling/binary_s4}}}\hspace{1em}
    \subfloat[5. iteration]{
        \label{region5}
        \fbox{\includegraphics[width=0.4\textwidth]{afsnit/implementation/billeder/billedbehandling/binary_s5}}}\\
    \subfloat[6. iteration]{
        \label{region6}
        \fbox{\includegraphics[width=0.4\textwidth]{afsnit/implementation/billeder/billedbehandling/binary_s6}}}\hspace{1em}
    \subfloat[7. iteration]{
        \label{region7}
        \fbox{\includegraphics[width=0.4\textwidth]{afsnit/implementation/billeder/billedbehandling/binary_s7}}}
        \caption[]{Iterationerne for kodeboks \ref{naiv_segmentering}}
    \label{region_extract}
\end{figure}

Kompleksiteten stiger, når vi ikke har med binære billeder at gøre. Som
vist i kapitel \ref{chap_afproevning}, så vil vi, på grund af
tærskelværdierne til \texttt{cvFloodFill} og \texttt{cvCanny}, ikke
nødvendigvis finde de samme regioner med de to metoder. Vi ønsker at
bruge kanterne, til at indikere en ny region, så det er ikke nok, at bruge
\texttt{cvFloodFill} på midten af et linjestykke mellem kanter. I figur
\ref{floodfill_taerskel_problem} er problemet illustreret, hvor sorte
streger er detekterede kanter og lyseblå indikerer den region vi har
fundet. Hvid farve er pixels, som endnu ikke er blevet farvet af
\texttt{cvFloodFill}.  Bemærk, at linjestykket, fra kanten af billedet
til den næste detekterede kant, som krydser snittet, \emph{ikke} er
blevet farvet helt lyseblå. Dette viser, at det ikke er ligemeget på
hvilken pixel vi bruger \texttt{cvFloodFill} på linjestykker mellem
kanter. Vi ønsker derfor, at male enhver pixel, på et givet linjestykke,
som \emph{endnu ikke er blevet farvet af \texttt{cvFloodFill}}.

\begin{figure}[p]
    \setlength\fboxsep{0pt}
    \setlength\fboxrule{0.5pt}
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{afsnit/implementation/billeder/billedbehandling/floodfill_color.png}}
    \caption[]{Problemet med floodfill-metoden i billeder med flere
    farver. Hvid farve er ikke blevet malet af floodfill-metoden endnu.
    Den lyseblå region dækker ikke hele linjestykket.}
    \label{floodfill_taerskel_problem}
\end{figure}

Fremgangsmåden, for at udtrække regioner ved et snit i et arbitrært
billede, er vist i kodeboks \ref{pseudo_udtraek_org}. Metoden tager
højde for den tidligere gjorte observation, hvor en allerede fundet
region bliver overskrevet. Regioner gemmes i $\angles{CutRegions}$ på
linje 20, som opretter en ny indgang med regionens id som nøgle.
Regionens id fåes ved kaldet \texttt{color.toString()}. Ved
inspektion ses det dog, at denne fremgangsmåde lider under nøjagtig
samme svaghed som fremgangsmåden brugt i figur \ref{region_extract}.

Under udviklingen af metoden i kodeboks \ref{pseudo_udtraek_org},
opdagede vi, at det ikke altid var hele regionen der blev returneret fra
\texttt{cvFloodFill}. Vi betragter nu figur \ref{new_reg_small_box},
hvor vi har udvidet den lyseblå region fra figur
\ref{floodfill_taerskel_problem}. Regionen som bliver lagt i instansen
af \textbf{cvConnectedComp}, er den \emph{senest udfyldte}. Derfor får vi
faktisk kun returneret et undersæt, af de pixels, som udgør den lyseblå
region.

\begin{figure}[p]
    \setlength\fboxsep{0pt}
    \setlength\fboxrule{0.5pt}
    \centering
    \subfloat[En tilføjelse til den lyseblå region. Det begrænsende
    rektangel svarer kun til udvidelsen.]{
        \label{new_reg_small_box}
        \fbox{\includegraphics[angle=0,width=0.8\textwidth]{afsnit/implementation/billeder/billedbehandling/floodfill_color_new_reg_small_box}}
        }\\
    \subfloat[Ved at bruge floodfill på regionen igen, markeres hele den
    lyseblå region, som vi ønsker.]{
        \label{new_reg_big_box}
        \fbox{\includegraphics[angle=0,width=0.8\textwidth]{afsnit/implementation/billeder/billedbehandling/floodfill_color_new_reg_big_box}}
        }
    \caption[]{
    Floodfills opførsel ved udvidelse af regioner.
    }
    \label{floodfill_return_entire_region}
\end{figure}

Problemet i \ref{new_reg_small_box} løses ved at bruge
\texttt{cvFloodFill} en ekstra gang. Derfor blev kaldet til
\texttt{cvFloodFill} i linje 17 tilføjet. Man bruger derfor
\texttt{cvFloodFill} igen på den sidste pixel af linjestykket, da dette
vil returnere hele regionen, som vist i
figur \ref{new_reg_big_box}. Kaldet gør dog også, at der \emph{altid}
bliver returneret en region for hvert segment. Dette er ikke
ønskværdigt, specielt ikke hvis vi er sprunget over alle pixels på et
linjestykke. Dette sker, netop når hele regionen allerede er blevet fyldt
ud. Fejlen i linje 17 har eksisteret selv under vores kørte eksperiment
i \marker{ref}{Husk husk husk}.
Vi har fjernet duplikaterne på databaseniveau, men metoden er senere
blevet rettet til at have den korrekte opførsel. Den reviderede metode
er vist i kodeboks \ref{pseudo_udtraek_rev}.

\begin{lstlisting}[caption={Revideret pseudokode til udtrækning af
    regioner. Returnerer ingen
    duplikater.},captionpos=b,label={pseudo_udtraek_rev},numbers=left,
    frame=tb, breaklines=false, float=p]
for lineSegment in Cut:
    # Get a new color that is not in the component dictionary
    color = getRandomColor()

    # Set region to None, as we have not yet found any
    region = None

    for pixel in lineSegment:

        # Check if the color of the pixel equals current color
        if not (color(pixel) ==  color):

            # Check if the color of the pixel are in the saved regions
            if not (color(pixel) in CutRegions):
                # Now we've got a new region
                region = cvConnectedComp()
                cv.cvFloodFill(img, pixel, color, lowerThres, upperThres, region)

                # Color the pixel again to make sure that
                # the returned component is the entire region
                cv.cvFloodFill(img, pixel, color, lowerThres, upperThres, region)

    # If we have found a region, then put the result in the CutRegions-dictionary
    if not (region is None):
        CutRegions[color.toString()] = (color, region)
\end{lstlisting}

Metoden i kodeboks \ref{pseudo_udtraek_rev} bruger \texttt{cvFloodFill}
to gange, hver gang man møder en ikke-farvet pixel. Dette koster lidt
køretid, men sikrer, at man altid får hele regionen returneret i
\textbf{cvConnectedComp}. Man kan fristes til at flytte kaldet i linje
21 ind i \texttt{if}-sætningen i linje 24, men dette åbner op for
svagheden igen, da vi ikke ved, om den sidste pixel tilhører den
aktuelle region. Derfor er vi nødt til at ofre lidt køretid, for at
være sikre på resultatet. Metoden benytter et ``først til
mølle''-princip, hvor en pixel, når den først et blevet tilknyttet en
region, altid vil tilhøre denne.

Pseudokoden i kodeboks \ref{pseudo_udtraek_rev} trækker dog kun de
regioner ud som rører snittet. I kapitel \ref{chap_detektion} indførtes
et margin, således at også regioner, som ligger tæt på snittet, kan
trækkes ud. Vi vil nu udvide pseudokoden i kodeboks
\ref{pseudo_udtraek_rev} til også at trække regioner ud, som krydser
margin. Vi navngiver metoden \texttt{ExtractRegions}, og den tager et
snit som argument. Metoden ses i kodeboks
\ref{pseudo_udtraek_margin}. Metoden trækker først regioner ud med
hensyn til det nedre margin, så med hensyn til det øvre margin og til
sidst med hensyn til selve snittet. Alle regioner gemmes i den samme
instans af $\angles{CutRatios}$. For selve udregningen af margin,
henvises til afsnit \ref{subsec_margin_udregning}.

\begin{lstlisting}[caption={Pseudokode til udtrækning af regioner med
    margin.},captionpos=b,label={pseudo_udtraek_margin},numbers=left,
    frame=tb, breaklines=false, float=h]
def ExtractRegions(cut):
    # Calculate lowerMargin and upperMargin
    (lowerMargin, upperMargin) = calculateMargins(cut)
    Cuts = [lowerMargin, upperMargin, cut]

    # Initialize an empty CutRegions-dict
    CutRegions = {}

    for Cut in Cuts:
        for lineSegment in Cut:
            # Get a new color that is not in the component dictionary
            color = getRandomColor()

            # Set region to None, as we have not yet found any
            region = None

            for pixel in lineSegment:

                # Check if the color of the pixel equals current color
                if not (color(pixel) ==  color):

                    # Check if the color of the pixel are in the saved regions
                    if not (color(pixel) in CutRegions):
                        # Now we've got a new region
                        region = cvConnectedComp()
                        cv.cvFloodFill(img, pixel, color,
                                    lowerThres, upperThres, region)

                        # Color the pixel again to make sure that
                        # the returned component is the entire region
                        cv.cvFloodFill(img, pixel, color,
                                    lowerThres, upperThres, region)

            # If we have found a region,
            # then put the result in the CutRegions-dictionary
            if not (region is None):
                CutRegions[color.toString()] = (color, region)

    return CutRegions
\end{lstlisting}

\subsection{Svagheder\label{subsec_svagheder}}
Den endelige metode, for udtrækning af regioner, med hensyn til et givet
snit i billedet, har nogle svagheder, som bør nævnes. Den første er
allerede nævnt i den foregående sætning: Metoden trækker kun regioner ud
\emph{med hensyn} til et snit. Dette betyder, at kun regioner, som rører
margin eller selve snittet, bliver trukket ud. Foregående skal tages
helt bogstaveligt, i den forstand, at vi \emph{skal} have, at en region
har en pixel enten på det nedre margin, det øvre margin eller på selve
snittet, for at blive trukket ud. Vi kan altså godt have interessante
regioner, som faktisk har mindst én kant af sit begrænsende rektangel
inden for margin, som ikke bliver trukket ud.  Dette er tilfældet, hvis
\emph{to kanter} af det begrænsende ligger indenfor snittet, og
regionens form og størrelse i øvrigt opfylder kravene for en interessant
region. Et eksempel er vist i figur \ref{respect_to_cut}, hvor den sorte
region ikke vil blive trukket ud, selvom den har to kanter inden for
margin. Denne opførsel er beklagelig, men kan faktisk løses trivielt.
\note{Dette er måske ikke skide-smart at skrive,
men det er et vagt forsøg på at dække over egen inkompetence. Skal vi
rette koden igen?}
Det overlades som opgave til læseren, at modificere pseudokoden i
kodeboks \ref{pseudo_udtraek_margin}, så den kan udtrække regioner med
begge kanter inden for margin.
Når regioner kun trækkes ud, med hensyn til et snit, kan vi ved denne
metode heller ikke garantere en fuld segmentering af billedet.

\begin{figure}[p]
    \setlength\fboxsep{0pt}
    \setlength\fboxrule{0.5pt}
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{afsnit/implementation/billeder/billedbehandling/respect_to_cut.png}}
    \caption[]{Sort region, som ikke bliver trukket ud af billedet.
    Selvom regionens begrænsende rektangel ligger inden for margin, så
    krydser regionen hverken nedre margin, øvre margin eller selve
    snittet. Derfor opdages regionen ikke.}
    \label{respect_to_cut}
\end{figure}

\subsubsection{Valg af tilfældige RGB-værdier}
Man skal endvidere være opmærksom på, at hver gang vi markerer en ny
region, vælges en tilfældig farve til denne.  Vi kan, i vores valg af
farve, være uheldig og vælge en, som bliver brugt i det originale
billede. Når vi kalder \texttt{cvFloodFill} igen, for at være sikre, at
hele regionen bliver returneret, kan vi smelte to regioner sammen, som
egentlig ikke burde hænge sammen. I figur \ref{floodfill_colors} er
denne situation vist på det prærarerede billede fra figur \ref{bathers}.
I samme forbindelse skal vi være opmærksomme på, at vi ligeledes kan
være uheldige, at støde på en pixel, som har en farve lig med en
allerede farvet region. I dette tilfælde, vil denne pixel blive anset
som værende del af en eksisterende region, hvilket resulterer i at vi
ikke bruger \texttt{cvFloodFill} på denne. Vi kan dog håbe, at denne
pixel bliver inkluderet i den efterfølgende iteration --- hvis den næste
pixels farve, da ikke er lig en allerede udvalgt regions, og denne
ligger inden for den tilladte afvigelse, for \texttt{cvFloodFill}.  Vi
vælger aldrig, at farve en region med en farve som allerede er brugt til
en region, men vi kan også her være uheldige og vælge en farve, som
ligger inden for floodfill-metodens tilladte afvigelse.

\begin{figure}[p]
    \setlength\fboxsep{0pt}
    \setlength\fboxrule{0.5pt}
    \centering
    \subfloat[Originalt præpareret billede inden vi vælger en tilfældig
    farve til floodfill.]{
        \label{colors_1}
        \fbox{\includegraphics[width=0.3\textwidth]{afsnit/implementation/billeder/billedbehandling/pre_floodfill_1}}}\hspace{1em}
    \subfloat[Region fyldes med farve lig eksisterende pixels i
    billedet. Pixels i drengens hår har nu samme farve som kroppen.]{
        \label{colors_2}
        \fbox{\includegraphics[width=0.3\textwidth]{afsnit/implementation/billeder/billedbehandling/pre_floodfill_2}}}\\
    \subfloat[Når floodfill bruges en ekstra gang, for at være sikker på
    at hele regionen returneres, smeltes drengens krop og hår sammen.]{
        \label{colors_3}
        \fbox{\includegraphics[width=0.3\textwidth]{afsnit/implementation/billeder/billedbehandling/pre_floodfill_3}}}\hspace{1em}
    \subfloat[Hvis den første region havde fået en anden farve, ville vi
    ikke have smeltet to regioner sammen.]{
        \label{colors_4}
        \fbox{\includegraphics[width=0.3\textwidth]{afsnit/implementation/billeder/billedbehandling/pre_floodfill_4}}}\\
    \label{floodfill_colors}
    \caption[]{Uheldige valg af tilfældig farve til regioner.}
\end{figure}

\subsubsection{Ikke-sammenhængende regioner}
Metoden i kodeboks \ref{pseudo_udtraek_margin}, trækker højest én region
ud per segment. Dette giver mening, set i lyset af hvad
udtrækningsmetoden er blevet udviklet til, nemlig udtrækning af
\emph{sammenhængende regioner} afgrænset ved kantdetektion. I afsnit
\ref{section_computer_betragter} antog vi, at interessante regioner i et
billede, er tydeligt afgrænset. En region er ikke tydeligt afgrænset,
hvis vi faktisk \emph{har} flere regioner indenfor et segment. I figur
\ref{usammenhaengende_region} betragter vi en hypotetisk situation, hvor
en region ikke har været tydeligt afgrænset. Billedet i figur
\ref{usammenhaengende_region}, illustrerer et billede, som allerede er
blevet segmenteret ved metoden i kodeboks \ref{pseudo_udtraek_margin}.
De sorte cirkler markerer dér, hvor vi har fundet kanter, som krydser
snittet. Vi har altså fem segmenter på snittet. På det længste segment,
ser vi, at den mørkeblå region er blevet afbrudt af en tidligere fundet
region. Den mørkeblå region er således ikke sammenhængende. Metoden
returnerer kun den nederste mørkeblå region, da vi ikke kan få forbundet
de to mørkeblå regioner. Vi mister derfor informationen om at der
faktisk befinder sig en region i midten af billedet.

Denne opførsel, er en konsekvens af vores antagelse, om at interessante
regioner er tydeligt afgrænset. Vi accepterer derfor, at situationen i
figur \ref{usammenhaengende_region} kan forekomme, og at vi derfor kan
undlade at trække enkelte regioner ud.

\begin{figure}[t]
    \setlength\fboxsep{0pt}
    \setlength\fboxrule{0.5pt}
    \centering
    \fbox{\includegraphics[width=0.8\textwidth]{afsnit/implementation/billeder/billedbehandling/usammenhaengende_region.png}}
    \caption[]{Et segmenteret billede. Sorte cirkler angiver steder,
    hvor vi har detekteret en kant, der krydser snittet. Den mørkeblå
    region er usammenhængende over snittet, da den afbrydes af den røde
    region. Kun den nederste mørkeblå region er blevet returneret.}
    \label{usammenhaengende_region}
\end{figure}

\subsubsection{Usikkerhed ved fremhævelse af kanter}
Endeligt skal vi nævne problemerne tilknyttet måden, vi fremhæver kanter
i et billede på. Som tidligere nævnt, så fremhæves kanterne, fordi vi
har sløret billedet med en metode, som kan udviske kanterne. De
fremhævede kanter, tegnes i det slørede billede, med sort farve, som
vælges uanset hvilke farver, der er brugt i maleriet i forvejen. Vi kan
derfor støde på problemer med mørke malerier eller lokalt i mørke
områder af et billede. Vi kan også være uheldige, at komme til at
forbinde to regioner, ved at markere kanterne med sort.

Vi valgte, at bruge sorte kanter, da dette var den hurtigste løsning på
daværende tidspunkt. Metoden \texttt{cvFloodFill} gør det faktisk
muligt, at bruge en maske, som, i mangel af et passende dansk ord, kan
beskrives som digital malertape. Man kan kalde \texttt{cvFloodFill} med
et kantdetekteret billede, således at man ikke maler over de steder i
billedet, hvor der er detekteret en kant. \emph{OpenCV} gør det dog
yderst besværligt, at bruge denne funktion, da det kantdetekterede
billede skal være to pixel større, i hver dimension --- det
kantdetekterede billede skal have en ramme på én pixel. At indsætte en
ramme burde være trivielt, men viste sig i praksis at være meget
besværligt. En meget naiv løsning, hvor pixels kopieres én ad gangen,
var tidskrævende på store billeder og vi beholdt derfor de sorte kanter.
Alternativt kunne man beskære det originale billede, men vi besluttede
at vi ikke ville manipulere med dimensionerne på vores inddata og bevare
det originale billede. På grund af, at kanterne kun males en anden
farve, kan vi, ved floodfill-metoden, komme til at male kanter, som har
samme retning som vi bevæger os i. Dvs, at lodrette kanter kan blive
malet ved vertikale snit og omvendt kan vandrette kanter risikere at
blive malet ved horisontale snit.

\subsection{Andre tilgange}
Dette afsnit vil kort nævne andre fremgangsmåder, vi har prøvet, for at
trække regioner ud af et billede. Vi har tidligt i udviklingen af
programmet, eksperimenteret både med Octave og Matlab. Til at starte
med, har vi brug disse sprog til at komme problemstillingen nærmere,
og udvikle naive implementationer af enkelte algoritmer.

I præparationen af billedet, inden udtrækning af regioner, vil vi gerne
have, at farverne i billedet bliver ensartede, men vi ønsker også at
bibeholde kanterne. Vi forsøgte at bruge en metode i \emph{OpenCV} der
hedder \texttt{cvPyrMeanShiftFiltering}, som netop segmenterer billedet
efter hvilke farver der ligner hinanden, men en fejl i biblioteket
forsagede altid en segmenteringsfejl i det underliggende C-program. Vi
blev siden gjort opmærksom på en sløringsmetode af Perona og
Malik\cite{perona1990scale}, hvor det grafiske resultat tilnærmer sig
det ønskede. Kun i Octaves \emph{Image}-pakke er denne implementeret. Vi
lavede en hurtig afprøvning, hvor resultatet fra denne metode blev
analyseret, men på basis at det endelige resultat, vurderede vi, at vi
godt kunne nøjes med at fremhæve kanterne i billedet efter en simpel
sløring.

Vi har også eksperimenteret med, først at skallere billedet ned, inden
man trak regioner ud. Dette gør nemlig, at kanterne forbliver intakte,
mens farverne, til en vis grad, bliver mere ensartede. Vi stødte dog på
problemer når billedet skulle skalleres op igen, eller rettere, få
resultaterne skalleret op, så de passede til originalbilledet. Vi mister
også meget præcision, når vi bruger et nedskalleret billede til at finde
regioner i.

}

%\begin{figure}[!h]
%    \centering
%    \begin{picture}(240,30)
%        \color{black}
%        \put(0, 10){$A$}
%        \put(233, 10){$B$}
%
%        \linethickness{5mm}
%        \put(85, 0){\line(1, 0){20}}
%
%        \linethickness{9mm}
%        \put(137, 3){\line(1, 0){24}}
%
%        \linethickness{3mm}
%        \put(203, 3){\line(1, 0){21}}
%
%        \linethickness{0.2mm}
%        \put(3, -5){\line(0, 1){10}}
%
%        \put(236, -5){\line(0, 1){10}}
%
%        \put(3, 0){\line(1, 0){233}}
%    \end{picture}
%    \caption[]{Eksempel på regioner der krydser snittet.}
%    \label{impUdtraek_regioner_snit}
%\end{figure}

% vim: set tw=72 spell spelllang=da:
